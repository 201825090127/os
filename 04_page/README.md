

# 分段到分页（分段有缺陷？）

* 内存分段机制下的地址访问

![](../04_page/imgs/1.jpg)

线性地址=》物理地址

* 分页机制下的地址访问

![](../04_page/imgs/2.jpg)

线性地址=》虚拟地址=》物理地址

* 分页机制的作用

![](../04_page/imgs/3.jpg)

当某个进程需要一块比较大的内存空间是，若物理地址没有连续的这么一块（即便其有很多块较小的，加起来也很大），在分段机制下，该进程仍然无法运行。
分页机制，把物理内存隐射到不同页中，分页机制提供虚拟的连续内存空间给那个进程，物理上可以达到不连续的效果。

分页机制本质：将大小不同的大内存段拆分成大小相等的小内存块，可以提供虚拟的连续内存空间。

# 分页问题与解决，地址如何映射

若一页1字节，那么4G内存空间要有4G个页，一个页要表示32位地址需要4B,页表存放在内存中，那么存放页表需要4G*4B =16GB大小，显然不合理。

4G内存=内存块数量*内存块大小（页数量*页的大小）

页大小为：4KB

页数量: 4GB / 4KB = 1M（1,048,576个页）

页表中需要有1,048,576个页表项

* 一级分页，二级分页

![](../04_page/imgs/4.jpg)

一页4KB,需要12bit来表示
1M的页表，需要20bit来表示，用来索引页表项

物理地址则有物理页与之对应，物理页的大小也是4KB,定位到物理页后，给出相应偏移，就能访问到该页中的任意1字节的物理内存了。

存储1M的页表，需要1M*4B(页表项32bit)=4M的存储

采用二级存储：一级是目录表，二级是页表

* 页目录表可以种页表个数为1K（1024个页表）,这1k个页表可以存放到任意的物理内存中，也不需要连续存放；

* 每个页表可以指定1k个物理地址空间的页（每个页表有1024个页表项，一页4KB）

*每个页表可以表示4M的内存地址， 整个页目录表表示4GB的内存地址

* 页目录的存储需要4KB物理内存，一个页表也要4kB物理内存

![](../04_page/imgs/5.jpg)

页目录表和页表都将存放到内存中

* 线性地址，到页表中对应的页表项，再到物理地址，映射过程（二级分页）

![](../04_page/imgs/6.jpg)

![](../04_page/imgs/7.jpg)

1. 虚拟地址高10位*4，作为页目录表内的偏移地址，加上目录表的物理地址，就能得到页目录的物理地址。读取页目录表的内容，可以得到页表的物理地址

2. 虚拟地址的中间10位*4，作为页表内的偏移地址，加上步骤1的页表物理地址，将得到页表项的物理地址。读取该页表项的内容，可以得到分配的物理页的地址。

3. 虚拟地址高10位和中间10位分别是PED和PTD的索引值，所以需要乘以4。低12位不是索引值，其范围是0-0xfff,作为页内偏移。步骤2的物理地址加上此偏移，得到最终的物理地址。

* 每个进程都将用户自己的页表，都有4G的虚拟内存空间

![](../04_page/imgs/8.jpg)


# 分页相关的实现机制

![](../04_page/imgs/7.jpg)

页目录表
```
31-12位 共20位，是物理地址（20位，因为物理页也是4KB）
AVL:可用
G:全局位，TLB高速缓存相关
D:脏页，当cpu对一个页面写操作时，将其设为1
A:访问位，是否被CPU访问过
PCD: Page-level Cache Disable,高速缓存是否禁用
PWT:Page-level Write-Through，页级写通
US:普通用户和超级用户位
RW:读写位
P:是否存在于物理内存中
```

页目录表得基址存于 **页目录基址寄存器PDBR（控制寄存器cr3）**, 其有32bit

![](../04_page/imgs/9.jpg)

一个页目录的32位含义比较丰富，这都是为分页机制，分页算法，内存访问相关而设定的，都是有意义的。

同理，**页目录项**

可以查阅相关资料，深入阅读。

* 具体实现分页机制，当然**分段**是前提
1. 实现好页目录表和页表
2. 页目录表基地址写入控制寄存器cr3
3. 控制寄存器cr0的PG为设为1，表示分页


# 程序实现

。。。